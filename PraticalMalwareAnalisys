- WinMD5 -> GUI calculate hash
- md5deep [file] -> command line calculate hash
- Strings program (http://bit.ly/ic4plL)
- Packed and obfuscated code will often include at least the functions LoadLibrary and GetProcAddress
- Unpack (upx -d file.exe) http://upx.sourceforge.net/

---- Several Microsoft Windows functions allow programmers to import
linked functions not listed in a program’s file header. Of these, the two most
commonly used are LoadLibrary and GetProcAddress. LdrGetProcAddress and
LdrLoadDll are also used. LoadLibrary and GetProcAddress allow a program to
access any function in any library on the system, which means that when
these functions are used, you can’t tell statically which functions are being
linked to by the suspect program. ----

- The Dependency Walker list only dinamically linked functions executable. http://www.dependencywalker.com/
- Common DLLs (Kernel32.dll, Advapi32.dll, User32.dll, Gdi32.dll, Ntdll.dll, WSock32.dll and
Ws2_32.dll, Wininet.dll.
- New functions suffix ex (Ex. ABCDEFex) and old functions continues support.
- Many functions that take strings as parameters include an A or a W at the end (one for ASCII strings and
one for wide character strings)

- GDI32.dll, SetWindowsHookEx indicate possible keylogging.
- Software\Microsoft\Windows\CurrentVersion\Run (commonly used by malware) controls which programs are automatically run when Windows starts up.
- PE file : 
.text = section contains the instructions that the CPU executes. 
.rdata = import and export information.
.data = programs global data.
.rsrc = resources used by exe, are not considere part of the exe.
.idata Sometimes present and stores the import function information; if this section is not present, the import function information is stored in the .rdata section.
.edata Sometimes present and stores the export function information; if this section is not present, the export function information is stored in the .rdata section.
.pdata Present only in 64-bit executables and stores exception-handling information.
.reloc Contains information for relocation of library files.

- PE file tools (PEView, Resource Hacker, PEBrowse, PEExplorer)
- WS2_32.dll  provides network functionality
- DLL malware may also need to be installed as a service, sometimes with aconvenient export such as InstallService.
- ProcMon - important filters for malware analysis are Process Name, Operation, and Detail.
- microprocessors - x86,x64, SPARC, PowerPC, MIPS, and ARM.
- main memory - data, code, heap, stack
- EAX - if you see the EAX register used immediately after a function call, you are probably seeing the code manipulate the return value.
- EFLAGS - ZF, CF, SF, TF.
- pusha pushes the 16-bit registers on the stack in the following order: AX, CX, DX, BX, SP, BP, SI, DI.
- pushad pushes the 32-bit registers on the stack in the following order: EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI.
- BOF - The most common data buffer manipulation instructions are movsx, cmpsx, stosx, and scasx, where x = b, w, or d for byte, word, or double word, respectively.
- CheckResult - Identify while condition
- The most commonly encountered request for a malicious kernel compo- nent is DeviceIoControl, which is a generic request from a user-space module to a device managed by a driver.
- Malicious drivers generally do not usually control hardware; instead, they interact with the main Windows kernel components, ntoskrnl.exe and hal.dll. The ntoskrnl.exe component has the code for the core OS functions, and hal.dll has the code for interacting with the main hardware components. Malware will often import functions from one or both of these files in order to manipulate the kernel.
- For example, if you want to look at disassembly of the NtCreateProcess function in ntoskrnl.exe, you would use the disassemble com- mand u (which stands for unassemble) with the parameter nt!NtCreateProcess. If you don’t specify a library name, WinDbg will search through all of the loaded modules for a matching symbol. This can take a long time because
it must load and search symbols for every module.
- The command x nt!*CreateProcess* will display exported functions as well as internal functions. The following is the output for x nt!*CreateProcess*. #WINDBG
- Another useful command is the ln command, which will list the closest symbol for a given memory address. #WINDBG

- When configured properly, WinDbg will query Microsoft’s server and automatically get the correct symbols for the files that are currently being debugged. You can set the symbol file path by selecting FileSymbol File Path. To configure WinDbg to use the online symbol server, enter the following path:
SRV*c:\websymbols*http://msdl.microsoft.com/download/symbols 
- Kernel modules are not loaded and unloaded often, so if you are debugging your malware and a kernel module is loaded, then you should be suspicious of the module.
- You can use the !devobj command to get device object information by using the name of the device specified by the CreateFile call from the user-space code.
- If you need to load an unsigned driver on an x64 Vista system, you can use the BCDEdit utility to modify the boot options. Specifically, nointegritychecks disables the requirement that drivers be signed.
- Downloaders commonly use the Windows API URLDownloadtoFileA, followed by a call to WinExec to download and execute new malware.
- Backdoors communicate over the Internet in numerous ways, but a common method is over port 80 using the HTTP protocol.
- msgina.dll > Microsoft’s Graphical Identification and Authentication (GINA)
- HASHs > Pwdump and the Pass-the-Hash (PSH) Toolkit are freely available pack- ages that provide hash dumping
- Hooking uses the Windows API to notify the malware each time a key is pressed, typically with the SetWindowsHookEx function. Polling uses the Windows API to con- stantly poll the state of the keys, typically using the GetAsyncKeyState and GetForegroundWindow functions.
- trojanizing binaries binaries known as DLL load-order hijacking.
- The AppInit_DLLs value is stored in the following Windows registry key: HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows
- WinLogon Notify HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\
- HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Svchost
- Services are defined in the registry at the following location: HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\ServiceName
- In the case of an svchost.exe DLL, this value contains %SystemRoot%/System32/svchost.exe –k GroupName. All svchost.exe DLLs contain a Parameters key with a ServiceDLL value, which the malware author sets to the location of the malicious DLL. 
- Inline hooking overwrites the API function code contained in the imported DLLs, so it must wait until the DLL is loaded to begin executing.
- the VirtualAllocEx function can be used to allocate space in an external process’s memory, and WriteProcessMemory can be used to write data to that allocated space. This pair of functions is essential to the first three loading techniques
- In order to inject the malicious DLL into a host program, the launcher malware must first obtain a handle to the victim process. The most common way is to use the Windows API calls CreateToolhelp32Snapshot, Process32First, and Process32Next to search the process list for the injection target. 
- When CreateRemoteThread is used, it is passed three important param- eters: the process handle (hProcess) obtained with OpenProcess, along with the starting point of the injected thread (lpStartAddress) and an argument for that thread (lpParameter)
- Malware authors generally use VirtualAllocEx to create space for the mali- cious library name string. The VirtualAllocEx function allocates space in a remote process if a handle to that process is provided.
- Three functions are commonly found in cases of direct injection: VirtualAllocEx, WriteProcessMemory, and CreateRemoteThread. There will typi- cally be two calls to VirtualAllocEx and WriteProcessMemory. The first will allo- cate and write the data used by the remote thread, and the second will allocate and write the remote thread code. The call to CreateRemoteThread will contain the location of the remote thread code (lpStartAddress) and the data (lpParameter).
- Once the process is created, the next step is to replace the victim process’s memory with the malicious executable, typically using ZwUnmapViewOfSection to release all memory pointed to by a section passed as a parameter. After the memory is unmapped, the loader performs VirtualAllocEx to allocate new memory for the malware, and uses WriteProcessMemory to write each of the malware sections to the victim process space, typically in a loop.
- There are two types of Windows hooks:
>> Local hooks are used to observe or manipulate messages destined for an internal process.
>> Remote hooks are used to observe or manipulate messages destined for a remote process (another process on the system).
- Keystrokes can be captured by register- ing high- or low-level hooks using the WH_KEYBOARD or WH_KEYBOARD_LL hook procedure types, respectively.
- APCs come in two forms:
>> An APC generated for the system or a driver is called a kernel-mode APC.
>> An APC generated for an application is called a user-mode APC. Malware generates user-mode APCs from both kernel and user space
using APC injection. 
- XOR techniques: If the plaintext character is NULL or the key itself, then the byte is skipped. If the plaintext character is neither NULL nor the key, then it is encoded via an XOR with the key.
- XOR instructions can be found in three forms: XOR of a register with itself OR XOR of a register (or memory reference) with a constant OR XOR of one register (or memory reference) with a different register (or memory reference)
- ADD, SUB: Encoding algorithms can use ADD and SUB for individual bytes in a manner that is similar to XOR. ADD and SUB are not reversible, so they need to be used in tandem (one to encode and the other to decode).
- ROL, ROR: Instructions rotate the bits within a byte right or left. Like ADD and SUB, these need to be used together since they are not reversible.
- ROT: This is the original Caesar cipher. It’s commonly used with either alpha- betical characters (A–Z and a–z) or the 94 printable characters in stan- dard ASCII.
- Multibyte: Instead of a single byte, an algorithm might use a longer key, often 4 or 8 bytes in length. This typically uses XOR for each block for convenience.
- Chained or Loopback: This algorithm uses the content itself as part of the key, with various imple- mentations. Most commonly, the original key is applied at one side of the plaintext (start or end), and the encoded output character is used as the key for the next character.
- MIME’s Base64, which uses A–Z, a–z, and 0–9 for the first 62 values, and + and / for the last two values. 
- Use FindCrypt2 or  Krypto ANALyzer (KANAL), for find crypt...
- The IDA Entropy Plugin (http://www.smokedchicken.org/2010/06/ida- entropy-plugin.html) is one tool that implements this technique for PE files. 
- One very common malware technique is to create identification for victim machine. This identification take many forms, encoded string, basic information, hashs...
- Windows Networking APIs
  WinSock API: WSAStartup, getaddrinfo, socket, connect, send, recv, WSAGetLastError.
  WinINet API: InternetOpen, InternetConnect, InternetOpenURL, InternetReadFile, InternetWriteFile, HTTPOpenRequest, HTTPQueryInfo, HTTPSendRequest.
  COM interface: URLDownloadToFile, CoInitialize, CoCreateInstance, Navigate.
  
-----Anti Debugger------

- The following Windows API functions can be used for anti-debugging: (IsDebuggerPresent, CheckRemoteDebuggerPresent, NtQueryInformationProcess, OutputDebugString)
- Manual ProcessHeap flag check = The best way to overcome this technique is to change the ProcessHeap flag manually or to use a hide-debug plug-in for your debugger.
- Checking NTGlobalFlag: The information that the system uses to determine how to create heap structures is stored at an undocumented loca- tion in the PEB at offset 0x68. If the value at this location is 0x70, we know that we are running in a debugger.
>> The easiest way to overcome this technique is to change the flags manu- ally or with a hide-debug plug-in for your debugger. If you are using WinDbg, you can start the program with the debug heap option disabled, as men- tioned in the previous section.
- Malware can search for this residue in order to determine when you are attempting to analyze it, such as by searching registry keys for references to debuggers. The following is a common location for a debugger:
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AeDebug
- Two Windows API functions are used like rdtsc in order to perform an anti- debugging timing check. QueryPerformanceCounter and GetTickCount.
- TLS Callbacks = Not many legitimate applications use TLS callbacks, so a .tls section in an executable can stand out..
- OllyDbg’s default settings; all exceptions will be trapped unless the box is checked. These options are accessed via OptionsDebugging OptionsExceptions.
- Most popular anti-debugging techniques involve accessing fs:[30h], calling a Windows API call, or performing a timing check.

-----ANTI-VIRTUAL MACHINE TECHNIQUES-----

- Red Pill Anti-VM Technique (search and read)
- Red Pill succeeds only on a single-processor machine. It won’t work con- sistently against multicore processors because each processor (guest or host) has an IDT assigned to it. Therefore, the result of the sidt instruction can vary, and the signature used by Red Pill can be unreliable.
- Perhaps the most popular anti-VMware technique currently in use is that of querying the I/O communication port. This technique is frequently encoun- tered in worms and bots, such as the Storm worm and Phatbot.
VMware uses virtual I/O ports for communication between the virtual machine and the host operating system to support functionality like copy and paste between the two systems. 
- Instructions used by malware to employ anti-VM techniques. These instructions are as follows: sidt, sgdt, sldt, smsw, str,  in (with the second operand set to VX), cpuid.
- ScoopyNG (http://www.trapkit.de/) is a free VMware detection tool that implements seven different checks for a virtual machine.


-------Packers and Unpacking-------

- If you attempt to perform static analysis on the packed program, you will be analyzing the stub, not the original program.
- Packer-detection tools such as PEiD can also be used to determine if an executable is packed.
- One such free automated tool is Mandiant Red Curtain, which cal- culates a threat score for any executable using measures such as entropy. Red Curtain can scan a filesystem for suspected packed binaries
- Most of the time, when you unpack mal- ware, you create a new binary that is not identical to the original, but does all the same things as the original.
- PE Explorer, a free program for working with EXE and DLL files, comes with several static unpacking plug-ins as part of the default setup. The default plug-ins support NSPack, UPack, and UPX. 
- To remove the packer, you need to locate the EOP.
- Common Packers > UPX, PECompact, ASPack, Petite, WinUpack, 
  - UPX > upx.exe -d file
  - PECompact > You can find the OEP by looking for the tail jump. Step over a few func- tions, and you will see a tail jump consisting of a jmp eax followed by many 0x00 bytes.
  - ASPack > Begin by opening the code for the unpacking stub. Early in the code, you will see a PUSHAD instruction. Determine which stack addresses are used to store the registers, and set a hardware breakpoint on one of those addresses. Ensure that it is set to break on a read instruction. When the corresponding POPAD instruction is called, the breakpoint will be triggered and you will be just a few instructions away from the tail jump that leads to the OEP.
  - Petite > The best strategy is to use a hardware breakpoint on the stack to find the OEP, as with ASPack.
  - WinUpack > The best strategy for finding the OEP for a program packed with UPack is to set a breakpoint on GetProcAddress, and then single-step carefully over instructions looking for the loops that set the import resolution.
               Another strategy that works on UPack is to set a breakpoint on GetModuleHandleA for GUI programs or GetCommandLineA for command-line programs.
  - Themida > Themida is a very complicated packer with many features. Most of the fea- tures are anti-debugging and anti-analysis, which make it a very secure packer that’s difficult to unpack and analyze.
- Some unpackers do not actually unpack the entire original program before the program begins running. Instead, they unpack a portion of the original program, and run that portion. When it is time to run the next por- tion of code, that portion is unpacked into memory and run. This creates considerable overhead for the executable, but makes it very difficult for an analyst to unpack.
- Unpacking a DLL is not much different from unpacking an EXE. The key thing to remember is that DLLs have an OEP, just like executables. All DLLs have a function called DllMain, which is called when the DLL is loaded. The OEP in a DLL is the original start of DllMain. The start address listed in the packed DLL is the address of the unpacking stub, which is placed into DllMain rather than into the main method. OllyDbg can load DLLs, and Olly- Dbg has a tool called loadDll.exe, which allows you to load and debug DLLs. The problem is that the DllMain method will be called prior to breaking in OllyDbg. By the time the break occurs, the unpacking stub will have already executed, and it will be very difficult to find the OEP.
To get around this, open the PE file and locate the Characteristics field in the IMAGE_FILE_HEADER section. The bit in the 0x2000 place in the IMAGE_FILE_HEADER is set to 1 for DLLs. If this field is changed to a 0, then the file will be interpreted as an executable. OllyDbg will open the program as an EXE, and you will be able to apply all of the unpacking strategies dis- cussed in this chapter. After you’ve found the OEP, change the bit back so that the program will be treated as a DLL again.
- 


-------Shellcode Analysis-------

- Shellcode encodings have additional benefits for the attackers, in that they make analysis more difficult by hiding human-readable strings such as URLs or IP addresses. Also, they may help evade network IDSs.
- The encoding understood by unescape treats the text %uXXYY as an encoded big-endian Unicode character, where XX and YY are hex values. On little-endian machines (such as x86), the byte sequence YY XX will be the result after decod- ing. For example, consider this text string:
  %u1122%u3344%u5566%u7788%u99aa%ubbcc%uddee
  > oth single- and double-byte encoded characters can be used within the same text string. This is a popular technique wherever JavaScript is used, including in PDF documents.
- The shellcode payload is usually found by looking for the typical process- injection API calls discussed in Chapter 12: VirtualAllocEx, WriteProcessMemory, and CreateRemoteThread. 
  


-------C++ Analysis-------

- The C++ calling convention for the this pointer is often called thiscall. Identifying the thiscall convention can be one easy way to identify object- oriented code when looking at disassembly.


-----Important Windows Functions-----

- Learn all Appendix A

-----Tools for Malware Analysis-----

- APATEDNS, AutoRuns, BinDiff, BinNavi, Bochs, BurpSuite, CaptureBat, CFF Explorer, DeepFreeze, Dependency Walker, Hex Editors, Hex-Rays Decompiler, 
IDA Pro, Immunity Debugger, Import REConstructor, INetSim, LordPE, Malcode Analyst Pack, Memoryze, Netcat, OfficeMalScanner, OllyDbg, OSR Driver Loader, PDF Dissector,
PDF Tools, PE Explorer, PEiD, PEview, Process Explorer, Process Hacker, Process Monitor, Python, RegShot, Resource Hacker, SandBoxes, Sandboxie and Buster Sandbox Analyzer,
Snort, Strings, TCPView, The Sleuth Kit, Tor, Truman, WinDbg, Wireshark, UPX, VERA, VirusTotal, VMware Workstation, Volatility Framework, YARA, Zero Wine.  



